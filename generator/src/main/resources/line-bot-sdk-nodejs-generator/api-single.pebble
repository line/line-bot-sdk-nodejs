{# @pebvariable name="imports" type="java.util.List<java.util.Map<String, String>>" #}
{# @pebvariable name="operations" type="org.openapitools.codegen.model.OperationMap" #}
{# @pebvariable name="authMethods" type="java.util.ArrayList<org.openapitools.codegen.CodegenSecurity>" -#}
{% include "./licenseInfo.pebble" %}

/* tslint:disable:no-unused-locals */
{% for import in imports -%}
import { {{import.classname}} } from '{{import.filename}}.js';
{% endfor %}
import * as Types from "../../types.js";
import {ensureJSON} from "../../utils.js";
import {Readable} from "node:stream";

import HTTPFetchClient, { convertResponseToReadable } from "../../http-fetch.js";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

interface httpClientConfig {
    baseURL?: string;
    {% if authMethods != null -%}
    channelAccessToken: string;
    {% endif -%}
    // TODO support defaultHeaders?
}


export class {{operations.classname}} {
    private httpClient: HTTPFetchClient;

    constructor(config: httpClientConfig) {
        const baseURL = config.baseURL || '{{endpoint(operations.classname)}}';
        this.httpClient = new HTTPFetchClient({
            defaultHeaders: {
                {% if authMethods != null -%}
                Authorization: "Bearer " + config.channelAccessToken,
                {% endif -%}
            },
            baseURL: baseURL,
        });
    }

    private async parseHTTPResponse(response: Response) {
        const { LINE_REQUEST_ID_HTTP_HEADER_NAME } = Types;
        let resBody: Record<string, any> = {
            ...await response.json(),
        };
        if (response.headers.get(LINE_REQUEST_ID_HTTP_HEADER_NAME)) {
            resBody[LINE_REQUEST_ID_HTTP_HEADER_NAME] =
                response.headers.get(LINE_REQUEST_ID_HTTP_HEADER_NAME);
        }
        return resBody;
    }

{% for op in operations.operation -%}
    /**
     * {{op.notes}}
    {% if op.summary -%}
     * @summary {{op.summary}}
    {% endif -%}
    {% for param in op.allParams -%}
     * @param {{param.paramName}} {{param.description}}
    {% endfor -%}
    {% if op.isDeprecated -%}
     * @deprecated
    {% endif -%}
    {% if op.externalDocs != null -%}
     * {{op.externalDocs.description}}
     * @see <a href="{{op.externalDocs.url}}">{{op.summary}} Documentation</a>
    {% endif -%}
     */
    public async {{op.nickname}}({% for param in op.allParams %}{{param.paramName}}{% if not param.required %}?{% endif %}: {{param.dataType}}, {% endfor %}) : Promise<{% if op.returnType %}{{ op.returnType }}{% else %}Types.MessageAPIResponseBase{% endif %}> {
        return (await this.{{op.nickname}}WithHttpInfo({% for param in op.allParams %}{{param.paramName}}, {% endfor %})).body;
    }

    /**
     * {{op.notes}}.
     * This method includes HttpInfo object to return additional information.
    {% if op.summary -%}
     * @summary {{op.summary}}
    {% endif -%}
    {% for param in op.allParams -%}
     * @param {{param.paramName}} {{param.description}}
    {% endfor -%}
    {% if op.isDeprecated -%}
     * @deprecated
    {% endif -%}
    {% if op.externalDocs != null -%}
     * {{op.externalDocs.description}}
     * @see <a href="{{op.externalDocs.url}}">{{op.summary}} Documentation</a>
    {% endif -%}
     */
    public async {{op.nickname}}WithHttpInfo({% for param in op.allParams %}{{param.paramName}}{% if not param.required %}?{% endif %}: {{param.dataType}}, {% endfor %}) : Promise<Types.ApiResponseType<{% if op.returnType %}{{ op.returnType }}{% else %}Types.MessageAPIResponseBase{% endif %}>> {
    {% if op.isMultipart %}
        {% include "./apiBody/multipart.pebble" %}
        {% else %}
        {% include "./apiBody/normal.pebble" %}
    {% endif %}
    }
{% endfor %}
}
